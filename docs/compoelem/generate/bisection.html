<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>compoelem.generate.bisection API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>compoelem.generate.bisection</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import itertools
from typing import Tuple, cast

import numpy as np
import numpy.linalg as la
from shapely.geometry import Polygon

from compoelem.config import config
from compoelem.detect.converter import k, p
from compoelem.types import *

body_direction_counter = 0
normal_body_direction_counter = 0
fallback_body_direction_counter = 0

def get_centroids_for_bisection(keypoints: Sequence[Keypoint], fallback: bool) -&gt; Tuple[Keypoint, Keypoint, Keypoint]:
    &#34;&#34;&#34;Helper method for transforming COCO input in a way that we can calculate the bisection vector of upper,
    middle and lower keypoints. Therefore we calculate the centroid of the keypoint pairs specified in 
    the config bisection.left_pose_points and bisection.right_pose_points

    Args:
        keypoints (Pose.keypoints): transformed COCO output

    Raises:
        ValueError: is raised if one of the above keypoints is missing

    Returns:
        Tuple[Keypoint, Keypoint, Keypoint]: top_kp, middle_kp, bottom_kp
    &#34;&#34;&#34;
    global body_direction_counter
    global normal_body_direction_counter
    global fallback_body_direction_counter
    body_direction_counter = body_direction_counter + 1

    keypoints_np = np.array(keypoints)
    left_kp = keypoints_np[config[&#34;bisection&#34;][&#34;left_pose_points&#34;]]
    right_kp = keypoints_np[config[&#34;bisection&#34;][&#34;right_pose_points&#34;]]

    left_shoulder_kp = keypoints_np[config[&#34;bisection&#34;][&#34;fallback&#34;][&#34;left_shoulder_kp&#34;]]
    right_shoulder_kp = keypoints_np[config[&#34;bisection&#34;][&#34;fallback&#34;][&#34;right_shoulder_kp&#34;]]
    left_eye_kp = keypoints_np[config[&#34;bisection&#34;][&#34;fallback&#34;][&#34;left_eye_kp&#34;]]
    right_eye_kp = keypoints_np[config[&#34;bisection&#34;][&#34;fallback&#34;][&#34;right_eye_kp&#34;]]
    with_fallback_kps: Sequence[Tuple[Keypoint,Keypoint]] = []
    if fallback:
        fb_used = False
        for idx, t in enumerate(zip(left_kp, right_kp)): # 0,1,8 &amp; 11
            if t[0].isNone or t[1].isNone:
                fb_used = True
                if idx == 0: # top point fallback
                    with_fallback_kps.append((left_eye_kp, right_eye_kp))
                if idx == 1: # middle point fallback
                    with_fallback_kps.append((left_shoulder_kp, right_shoulder_kp))
                if idx == 2: # bottom point fallback
                    l_middle_point_pair, r_middle_point_pair = with_fallback_kps[-1]
                    left_bottom_fallback = Keypoint(l_middle_point_pair.x, l_middle_point_pair.y + 40, 1)
                    right_bottom_fallback = Keypoint(r_middle_point_pair.x, r_middle_point_pair.y + 40, 1)
                    with_fallback_kps.append((left_bottom_fallback, right_bottom_fallback)) #actually they can be the same. Since we calculate the centroid anyways
            else:
                with_fallback_kps.append(t)
        if fb_used:
            fallback_body_direction_counter = fallback_body_direction_counter + 1
        else:
            normal_body_direction_counter = normal_body_direction_counter + 1

    bisection_keypoint_pairs: Sequence[Tuple[Keypoint,Keypoint]] = list(
        filter(lambda x: not (x[0].isNone or x[1].isNone), with_fallback_kps if fallback else zip(left_kp, right_kp,))
    )
    if len(bisection_keypoint_pairs) != 3:
        raise ValueError(&#39;some keypoints for bisection calculation are missing!&#39;)
    keypoint_pairs = [
        Keypoint(*p(cast(Point, LineString([k(a),k(b)]).centroid)), np.mean([a.score, b.score]))
        for a,b in bisection_keypoint_pairs
    ]
    top_kp, middle_kp, bottom_kp = keypoint_pairs
    # print(&#34;body_direction_counter, normal_body_direction_counter, fallback_body_direction_counter&#34;, body_direction_counter, normal_body_direction_counter, fallback_body_direction_counter)
    return top_kp, middle_kp, bottom_kp

def keypoint_to_point(k: Keypoint) -&gt; Point:
    return Point(k.x, k.y)

def keypoint_to_vector(a: Keypoint, b: Keypoint) -&gt; np.ndarray:
    return keypoint_to_np(a) - keypoint_to_np(b)

def keypoint_to_np(keypoint: Keypoint) -&gt; np.ndarray:
    return np.array([keypoint.x, keypoint.y])

def get_bisection_point(top_kp: Keypoint, middle_kp: Keypoint, bottom_kp: Keypoint) -&gt; Keypoint:
    &#34;&#34;&#34;Returns the end point of the bisection vector of three input points.
    The length of the vector is the double of the length from top_kp to middle_kp.

    Args:
        top_kp (Keypoint): Some keypoint from head region
        middle_kp (Keypoint): Some keypoint from upper body region
        bottom_kp (Keypoint): Some keypoint from lower body region

    Returns:
        Keypoint: Endpoint of bisection vector
    &#34;&#34;&#34;
    phi = get_angle(top_kp, middle_kp, bottom_kp) - np.deg2rad(int(config[&#34;bisection&#34;][&#34;correction_angle&#34;])) #TODO: check if this correction_angle is correct for both directions (bisection vector show to the left or right (clockwise/counterclockwise rotation))
    return get_bisection_point_from_angle(top_kp, middle_kp, phi)

def get_bisection_point_from_angle(top_kp: Keypoint, middle_kp: Keypoint, phi: float, scale: float = 1) -&gt; Keypoint:
    theta = phi / 2 * -1 
    x, y = keypoint_to_vector(top_kp, middle_kp)
    x_new = x * np.cos(theta) - y * np.sin(theta)
    y_new = x * np.sin(theta) + y * np.cos(theta)
    return Keypoint(x_new * scale + middle_kp.x, y_new * scale + middle_kp.y)

def get_angle(a: Keypoint, b: Keypoint, c: Keypoint) -&gt; float:
    &#34;&#34;&#34;Get angle between vector b-&gt;a and b-&gt;c by calculating the scalarproduct.
    Because the scalarproduct looses track of the orientation of the angle we further
    calculate the orientation with the help of the crossproduct and return it with the sign of the returned angle

    Args:
        a (Keypoint): first keypoint
        b (Keypoint): middle keypoint
        c (Keypoint): last keypoint

    Returns:
        float: angle in radians. Positive if angle is left rotating and positiv if right rotating
    &#34;&#34;&#34;
    # get a vector with origin in (0,0) from points a and b by substracting Point a from Point b
    vector_a = keypoint_to_vector(a, b)
    vector_c = keypoint_to_vector(c, b)
    # https://de.wikipedia.org/wiki/Skalarprodukt =&gt; winkel phi = arccos(...)
    phi = np.arccos(np.dot(vector_a, vector_c) / (np.linalg.norm(vector_a) * np.linalg.norm(vector_c)))
    angle_left_opening = np.cross(vector_a, vector_c) &lt; 0
    return phi if angle_left_opening else -phi

def get_horizantal_b_reference(top_kp: Keypoint, middle_kp: Keypoint, bottom_kp: Keypoint) -&gt; Keypoint:
    &#34;&#34;&#34;Returns an reference Keypoint by adding or substracting 100px from middle_kp x-coordinate.
    If the smaller angle between the three keypoints is on the left side we substract 100px else we add 100px.
    Using this keypoint together with the middle_kp to create a parallel line to the x axis

    Args:
        top_kp (Keypoint): Some keypoint from head region
        middle_kp (Keypoint): Some keypoint from upper body region
        bottom_kp (Keypoint): Some keypoint from lower body region

    Returns:
        Keypoint: returns an reference Keypoint.
    &#34;&#34;&#34;
    vector_a = keypoint_to_vector(top_kp, middle_kp)
    vector_c = keypoint_to_vector(bottom_kp, middle_kp)
    # NOTE: checking angle_left_opening has the same effect as to check if biscetion point is positioned to the left or right of the neck point
    angle_left_opening = np.cross(vector_a, vector_c) &lt; 0
    return Keypoint(middle_kp.x - 100, middle_kp.y) if angle_left_opening else Keypoint(middle_kp.x + 100, middle_kp.y)

def get_bisection_cone(top_kp: Keypoint, middle_kp: Keypoint, bottom_kp: Keypoint) -&gt; Polygon:
    cone_offset_angle = np.deg2rad(int(config[&#34;bisection&#34;][&#34;cone_opening_angle&#34;])/2)
    cone_scale_factor = float(config[&#34;bisection&#34;][&#34;cone_scale_factor&#34;])
    cone_base_scale_factor = float(config[&#34;bisection&#34;][&#34;cone_base_scale_factor&#34;])
    # print(cone_offset_angle, cone_scale_factor)
    phi = get_angle(top_kp, middle_kp, bottom_kp) - np.deg2rad(int(config[&#34;bisection&#34;][&#34;correction_angle&#34;]))
    # cone points
    cone_endpoint1 = get_bisection_point_from_angle(top_kp, middle_kp, phi + cone_offset_angle, cone_scale_factor)
    cone_endpoint2 = get_bisection_point_from_angle(top_kp, middle_kp, phi - cone_offset_angle, cone_scale_factor)
    cone_startpoint1 = get_bisection_point_from_angle(top_kp, middle_kp, phi + np.deg2rad(config[&#34;bisection&#34;][&#34;cone_base_angle&#34;]), cone_base_scale_factor)
    cone_startpoint2 = get_bisection_point_from_angle(top_kp, middle_kp, phi - np.deg2rad(config[&#34;bisection&#34;][&#34;cone_base_angle&#34;]), cone_base_scale_factor)
    cone = Polygon([keypoint_to_np(cone_endpoint1), keypoint_to_np(cone_endpoint2), keypoint_to_np(cone_startpoint2), keypoint_to_np(cone_startpoint1)])
    # if phi &gt; 0:
    #     cone = Polygon([keypoint_to_np(cone1), keypoint_to_np(cone2), [middle_kp.x, middle_kp.y - 20], [middle_kp.x, middle_kp.y + 20]]) # new
    # else:
    #     cone = Polygon([keypoint_to_np(cone1), keypoint_to_np(cone2), [middle_kp.x, middle_kp.y + 20], [middle_kp.x, middle_kp.y - 20]]) # new
    return cone

def get_angle_in_respect_to_x(top_kp: Keypoint, middle_kp: Keypoint, bottom_kp: Keypoint) -&gt; float:
    &#34;&#34;&#34;Calculates the angle from the three input keypoints in respect to the x-axis.
    A positive value indicates a increasing slope and a negative a decreasing slope.

    Args:
        top_kp (Keypoint): Some keypoint from head region
        middle_kp (Keypoint): Some keypoint from upper body region
        bottom_kp (Keypoint): Some keypoint from lower body region

    Returns:
        float: angle in radians in respect to x-axis
    &#34;&#34;&#34;
    bisect_point = get_bisection_point(top_kp, middle_kp, bottom_kp)
    horizontal_middle_kp_reference = get_horizantal_b_reference(top_kp, middle_kp, bottom_kp)
    gamma = get_angle(horizontal_middle_kp_reference, middle_kp, bisect_point)
    return gamma

def keypoint_to_np(keypoint: Keypoint) -&gt; np.ndarray:
    return np.array([keypoint.x, keypoint.y])

# #previuosly angleMapper
# def get_mapped_angle(top_kp: Keypoint, middle_kp: Keypoint, bottom_kp: Keypoint) -&gt; float:
#     a = np.array([top_kp.x, top_kp.y])
#     b = np.array([middle_kp.x, middle_kp.y])
#     c = np.array([bottom_kp.x, bottom_kp.y])
#     angle = getAngleGroundNormed(a,b,c)
#      #map all angles to one direction, so the mean does not get influences by left/right direction
#     if(angle &gt; np.deg2rad(180)):
#         mapped = angle - np.deg2rad(180)
#         return mapped - np.deg2rad(180) if mapped &gt; np.deg2rad(90) else mapped
#     else:
#         mapped = angle
#         return mapped - np.deg2rad(180) if mapped &gt; np.deg2rad(90) else mapped

# def angleMapper(pose):
#     angle = getAngleGroundNormed(*pose[[0,1,8]][:,:2])
#      #map all angles to one direction, so the mean does not get influences by left/right direction
#     if(angle &gt; np.deg2rad(180)):
#         mapped = angle - np.deg2rad(180)
#         return mapped - np.deg2rad(180) if mapped &gt; np.deg2rad(90) else mapped
#     else:
#         mapped = angle
#         return mapped - np.deg2rad(180) if mapped &gt; np.deg2rad(90) else mapped

# def getGlobalLineAngle(poses):
#     return np.mean([angleMapper(pose) for pose in poses if not 0.0 in pose[[0,1,8]][:,2:]])

# def getBisecPoint(a,b,c) -&gt; Tuple[int, int]:
#     angle = getAngleGroundNormed(a,b,c)
#     dist = la.norm(a-b)*2
#     d = (int(dist * np.cos(angle)), int(dist * np.sin(angle))) #with origin zero
#     out = (b[0]+d[0],b[1]-d[1])
#     return out #with origin b

# def poseToBisectVector(pose):
#     points = pose[[0,1,8]]
#     if(0.0 in points[:,2:]): #if one point has confidence zero, we can not generate the vector
#         return None
#     a,b,c = points[:,:2] # cut of confidence score so we have normal coordinate points
#     bisecPoint = getBisecPoint(a,b,c)
#     return np.array([bisecPoint,b])</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="compoelem.generate.bisection.get_angle"><code class="name flex">
<span>def <span class="ident">get_angle</span></span>(<span>a: <a title="compoelem.types.Keypoint" href="../types.html#compoelem.types.Keypoint">Keypoint</a>, b: <a title="compoelem.types.Keypoint" href="../types.html#compoelem.types.Keypoint">Keypoint</a>, c: <a title="compoelem.types.Keypoint" href="../types.html#compoelem.types.Keypoint">Keypoint</a>) ‑> float</span>
</code></dt>
<dd>
<div class="desc"><p>Get angle between vector b-&gt;a and b-&gt;c by calculating the scalarproduct.
Because the scalarproduct looses track of the orientation of the angle we further
calculate the orientation with the help of the crossproduct and return it with the sign of the returned angle</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>a</code></strong> :&ensp;<code>Keypoint</code></dt>
<dd>first keypoint</dd>
<dt><strong><code>b</code></strong> :&ensp;<code>Keypoint</code></dt>
<dd>middle keypoint</dd>
<dt><strong><code>c</code></strong> :&ensp;<code>Keypoint</code></dt>
<dd>last keypoint</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>angle in radians. Positive if angle is left rotating and positiv if right rotating</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_angle(a: Keypoint, b: Keypoint, c: Keypoint) -&gt; float:
    &#34;&#34;&#34;Get angle between vector b-&gt;a and b-&gt;c by calculating the scalarproduct.
    Because the scalarproduct looses track of the orientation of the angle we further
    calculate the orientation with the help of the crossproduct and return it with the sign of the returned angle

    Args:
        a (Keypoint): first keypoint
        b (Keypoint): middle keypoint
        c (Keypoint): last keypoint

    Returns:
        float: angle in radians. Positive if angle is left rotating and positiv if right rotating
    &#34;&#34;&#34;
    # get a vector with origin in (0,0) from points a and b by substracting Point a from Point b
    vector_a = keypoint_to_vector(a, b)
    vector_c = keypoint_to_vector(c, b)
    # https://de.wikipedia.org/wiki/Skalarprodukt =&gt; winkel phi = arccos(...)
    phi = np.arccos(np.dot(vector_a, vector_c) / (np.linalg.norm(vector_a) * np.linalg.norm(vector_c)))
    angle_left_opening = np.cross(vector_a, vector_c) &lt; 0
    return phi if angle_left_opening else -phi</code></pre>
</details>
</dd>
<dt id="compoelem.generate.bisection.get_angle_in_respect_to_x"><code class="name flex">
<span>def <span class="ident">get_angle_in_respect_to_x</span></span>(<span>top_kp: <a title="compoelem.types.Keypoint" href="../types.html#compoelem.types.Keypoint">Keypoint</a>, middle_kp: <a title="compoelem.types.Keypoint" href="../types.html#compoelem.types.Keypoint">Keypoint</a>, bottom_kp: <a title="compoelem.types.Keypoint" href="../types.html#compoelem.types.Keypoint">Keypoint</a>) ‑> float</span>
</code></dt>
<dd>
<div class="desc"><p>Calculates the angle from the three input keypoints in respect to the x-axis.
A positive value indicates a increasing slope and a negative a decreasing slope.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>top_kp</code></strong> :&ensp;<code>Keypoint</code></dt>
<dd>Some keypoint from head region</dd>
<dt><strong><code>middle_kp</code></strong> :&ensp;<code>Keypoint</code></dt>
<dd>Some keypoint from upper body region</dd>
<dt><strong><code>bottom_kp</code></strong> :&ensp;<code>Keypoint</code></dt>
<dd>Some keypoint from lower body region</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>angle in radians in respect to x-axis</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_angle_in_respect_to_x(top_kp: Keypoint, middle_kp: Keypoint, bottom_kp: Keypoint) -&gt; float:
    &#34;&#34;&#34;Calculates the angle from the three input keypoints in respect to the x-axis.
    A positive value indicates a increasing slope and a negative a decreasing slope.

    Args:
        top_kp (Keypoint): Some keypoint from head region
        middle_kp (Keypoint): Some keypoint from upper body region
        bottom_kp (Keypoint): Some keypoint from lower body region

    Returns:
        float: angle in radians in respect to x-axis
    &#34;&#34;&#34;
    bisect_point = get_bisection_point(top_kp, middle_kp, bottom_kp)
    horizontal_middle_kp_reference = get_horizantal_b_reference(top_kp, middle_kp, bottom_kp)
    gamma = get_angle(horizontal_middle_kp_reference, middle_kp, bisect_point)
    return gamma</code></pre>
</details>
</dd>
<dt id="compoelem.generate.bisection.get_bisection_cone"><code class="name flex">
<span>def <span class="ident">get_bisection_cone</span></span>(<span>top_kp: <a title="compoelem.types.Keypoint" href="../types.html#compoelem.types.Keypoint">Keypoint</a>, middle_kp: <a title="compoelem.types.Keypoint" href="../types.html#compoelem.types.Keypoint">Keypoint</a>, bottom_kp: <a title="compoelem.types.Keypoint" href="../types.html#compoelem.types.Keypoint">Keypoint</a>) ‑> shapely.geometry.polygon.Polygon</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_bisection_cone(top_kp: Keypoint, middle_kp: Keypoint, bottom_kp: Keypoint) -&gt; Polygon:
    cone_offset_angle = np.deg2rad(int(config[&#34;bisection&#34;][&#34;cone_opening_angle&#34;])/2)
    cone_scale_factor = float(config[&#34;bisection&#34;][&#34;cone_scale_factor&#34;])
    cone_base_scale_factor = float(config[&#34;bisection&#34;][&#34;cone_base_scale_factor&#34;])
    # print(cone_offset_angle, cone_scale_factor)
    phi = get_angle(top_kp, middle_kp, bottom_kp) - np.deg2rad(int(config[&#34;bisection&#34;][&#34;correction_angle&#34;]))
    # cone points
    cone_endpoint1 = get_bisection_point_from_angle(top_kp, middle_kp, phi + cone_offset_angle, cone_scale_factor)
    cone_endpoint2 = get_bisection_point_from_angle(top_kp, middle_kp, phi - cone_offset_angle, cone_scale_factor)
    cone_startpoint1 = get_bisection_point_from_angle(top_kp, middle_kp, phi + np.deg2rad(config[&#34;bisection&#34;][&#34;cone_base_angle&#34;]), cone_base_scale_factor)
    cone_startpoint2 = get_bisection_point_from_angle(top_kp, middle_kp, phi - np.deg2rad(config[&#34;bisection&#34;][&#34;cone_base_angle&#34;]), cone_base_scale_factor)
    cone = Polygon([keypoint_to_np(cone_endpoint1), keypoint_to_np(cone_endpoint2), keypoint_to_np(cone_startpoint2), keypoint_to_np(cone_startpoint1)])
    # if phi &gt; 0:
    #     cone = Polygon([keypoint_to_np(cone1), keypoint_to_np(cone2), [middle_kp.x, middle_kp.y - 20], [middle_kp.x, middle_kp.y + 20]]) # new
    # else:
    #     cone = Polygon([keypoint_to_np(cone1), keypoint_to_np(cone2), [middle_kp.x, middle_kp.y + 20], [middle_kp.x, middle_kp.y - 20]]) # new
    return cone</code></pre>
</details>
</dd>
<dt id="compoelem.generate.bisection.get_bisection_point"><code class="name flex">
<span>def <span class="ident">get_bisection_point</span></span>(<span>top_kp: <a title="compoelem.types.Keypoint" href="../types.html#compoelem.types.Keypoint">Keypoint</a>, middle_kp: <a title="compoelem.types.Keypoint" href="../types.html#compoelem.types.Keypoint">Keypoint</a>, bottom_kp: <a title="compoelem.types.Keypoint" href="../types.html#compoelem.types.Keypoint">Keypoint</a>) ‑> <a title="compoelem.types.Keypoint" href="../types.html#compoelem.types.Keypoint">Keypoint</a></span>
</code></dt>
<dd>
<div class="desc"><p>Returns the end point of the bisection vector of three input points.
The length of the vector is the double of the length from top_kp to middle_kp.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>top_kp</code></strong> :&ensp;<code>Keypoint</code></dt>
<dd>Some keypoint from head region</dd>
<dt><strong><code>middle_kp</code></strong> :&ensp;<code>Keypoint</code></dt>
<dd>Some keypoint from upper body region</dd>
<dt><strong><code>bottom_kp</code></strong> :&ensp;<code>Keypoint</code></dt>
<dd>Some keypoint from lower body region</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Keypoint</code></dt>
<dd>Endpoint of bisection vector</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_bisection_point(top_kp: Keypoint, middle_kp: Keypoint, bottom_kp: Keypoint) -&gt; Keypoint:
    &#34;&#34;&#34;Returns the end point of the bisection vector of three input points.
    The length of the vector is the double of the length from top_kp to middle_kp.

    Args:
        top_kp (Keypoint): Some keypoint from head region
        middle_kp (Keypoint): Some keypoint from upper body region
        bottom_kp (Keypoint): Some keypoint from lower body region

    Returns:
        Keypoint: Endpoint of bisection vector
    &#34;&#34;&#34;
    phi = get_angle(top_kp, middle_kp, bottom_kp) - np.deg2rad(int(config[&#34;bisection&#34;][&#34;correction_angle&#34;])) #TODO: check if this correction_angle is correct for both directions (bisection vector show to the left or right (clockwise/counterclockwise rotation))
    return get_bisection_point_from_angle(top_kp, middle_kp, phi)</code></pre>
</details>
</dd>
<dt id="compoelem.generate.bisection.get_bisection_point_from_angle"><code class="name flex">
<span>def <span class="ident">get_bisection_point_from_angle</span></span>(<span>top_kp: <a title="compoelem.types.Keypoint" href="../types.html#compoelem.types.Keypoint">Keypoint</a>, middle_kp: <a title="compoelem.types.Keypoint" href="../types.html#compoelem.types.Keypoint">Keypoint</a>, phi: float, scale: float = 1) ‑> <a title="compoelem.types.Keypoint" href="../types.html#compoelem.types.Keypoint">Keypoint</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_bisection_point_from_angle(top_kp: Keypoint, middle_kp: Keypoint, phi: float, scale: float = 1) -&gt; Keypoint:
    theta = phi / 2 * -1 
    x, y = keypoint_to_vector(top_kp, middle_kp)
    x_new = x * np.cos(theta) - y * np.sin(theta)
    y_new = x * np.sin(theta) + y * np.cos(theta)
    return Keypoint(x_new * scale + middle_kp.x, y_new * scale + middle_kp.y)</code></pre>
</details>
</dd>
<dt id="compoelem.generate.bisection.get_centroids_for_bisection"><code class="name flex">
<span>def <span class="ident">get_centroids_for_bisection</span></span>(<span>keypoints: Sequence[<a title="compoelem.types.Keypoint" href="../types.html#compoelem.types.Keypoint">Keypoint</a>], fallback: bool) ‑> Tuple[<a title="compoelem.types.Keypoint" href="../types.html#compoelem.types.Keypoint">Keypoint</a>, <a title="compoelem.types.Keypoint" href="../types.html#compoelem.types.Keypoint">Keypoint</a>, <a title="compoelem.types.Keypoint" href="../types.html#compoelem.types.Keypoint">Keypoint</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Helper method for transforming COCO input in a way that we can calculate the bisection vector of upper,
middle and lower keypoints. Therefore we calculate the centroid of the keypoint pairs specified in
the config bisection.left_pose_points and bisection.right_pose_points</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>keypoints</code></strong> :&ensp;<code>Pose.keypoints</code></dt>
<dd>transformed COCO output</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>is raised if one of the above keypoints is missing</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Tuple[Keypoint, Keypoint, Keypoint]</code></dt>
<dd>top_kp, middle_kp, bottom_kp</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_centroids_for_bisection(keypoints: Sequence[Keypoint], fallback: bool) -&gt; Tuple[Keypoint, Keypoint, Keypoint]:
    &#34;&#34;&#34;Helper method for transforming COCO input in a way that we can calculate the bisection vector of upper,
    middle and lower keypoints. Therefore we calculate the centroid of the keypoint pairs specified in 
    the config bisection.left_pose_points and bisection.right_pose_points

    Args:
        keypoints (Pose.keypoints): transformed COCO output

    Raises:
        ValueError: is raised if one of the above keypoints is missing

    Returns:
        Tuple[Keypoint, Keypoint, Keypoint]: top_kp, middle_kp, bottom_kp
    &#34;&#34;&#34;
    global body_direction_counter
    global normal_body_direction_counter
    global fallback_body_direction_counter
    body_direction_counter = body_direction_counter + 1

    keypoints_np = np.array(keypoints)
    left_kp = keypoints_np[config[&#34;bisection&#34;][&#34;left_pose_points&#34;]]
    right_kp = keypoints_np[config[&#34;bisection&#34;][&#34;right_pose_points&#34;]]

    left_shoulder_kp = keypoints_np[config[&#34;bisection&#34;][&#34;fallback&#34;][&#34;left_shoulder_kp&#34;]]
    right_shoulder_kp = keypoints_np[config[&#34;bisection&#34;][&#34;fallback&#34;][&#34;right_shoulder_kp&#34;]]
    left_eye_kp = keypoints_np[config[&#34;bisection&#34;][&#34;fallback&#34;][&#34;left_eye_kp&#34;]]
    right_eye_kp = keypoints_np[config[&#34;bisection&#34;][&#34;fallback&#34;][&#34;right_eye_kp&#34;]]
    with_fallback_kps: Sequence[Tuple[Keypoint,Keypoint]] = []
    if fallback:
        fb_used = False
        for idx, t in enumerate(zip(left_kp, right_kp)): # 0,1,8 &amp; 11
            if t[0].isNone or t[1].isNone:
                fb_used = True
                if idx == 0: # top point fallback
                    with_fallback_kps.append((left_eye_kp, right_eye_kp))
                if idx == 1: # middle point fallback
                    with_fallback_kps.append((left_shoulder_kp, right_shoulder_kp))
                if idx == 2: # bottom point fallback
                    l_middle_point_pair, r_middle_point_pair = with_fallback_kps[-1]
                    left_bottom_fallback = Keypoint(l_middle_point_pair.x, l_middle_point_pair.y + 40, 1)
                    right_bottom_fallback = Keypoint(r_middle_point_pair.x, r_middle_point_pair.y + 40, 1)
                    with_fallback_kps.append((left_bottom_fallback, right_bottom_fallback)) #actually they can be the same. Since we calculate the centroid anyways
            else:
                with_fallback_kps.append(t)
        if fb_used:
            fallback_body_direction_counter = fallback_body_direction_counter + 1
        else:
            normal_body_direction_counter = normal_body_direction_counter + 1

    bisection_keypoint_pairs: Sequence[Tuple[Keypoint,Keypoint]] = list(
        filter(lambda x: not (x[0].isNone or x[1].isNone), with_fallback_kps if fallback else zip(left_kp, right_kp,))
    )
    if len(bisection_keypoint_pairs) != 3:
        raise ValueError(&#39;some keypoints for bisection calculation are missing!&#39;)
    keypoint_pairs = [
        Keypoint(*p(cast(Point, LineString([k(a),k(b)]).centroid)), np.mean([a.score, b.score]))
        for a,b in bisection_keypoint_pairs
    ]
    top_kp, middle_kp, bottom_kp = keypoint_pairs
    # print(&#34;body_direction_counter, normal_body_direction_counter, fallback_body_direction_counter&#34;, body_direction_counter, normal_body_direction_counter, fallback_body_direction_counter)
    return top_kp, middle_kp, bottom_kp</code></pre>
</details>
</dd>
<dt id="compoelem.generate.bisection.get_horizantal_b_reference"><code class="name flex">
<span>def <span class="ident">get_horizantal_b_reference</span></span>(<span>top_kp: <a title="compoelem.types.Keypoint" href="../types.html#compoelem.types.Keypoint">Keypoint</a>, middle_kp: <a title="compoelem.types.Keypoint" href="../types.html#compoelem.types.Keypoint">Keypoint</a>, bottom_kp: <a title="compoelem.types.Keypoint" href="../types.html#compoelem.types.Keypoint">Keypoint</a>) ‑> <a title="compoelem.types.Keypoint" href="../types.html#compoelem.types.Keypoint">Keypoint</a></span>
</code></dt>
<dd>
<div class="desc"><p>Returns an reference Keypoint by adding or substracting 100px from middle_kp x-coordinate.
If the smaller angle between the three keypoints is on the left side we substract 100px else we add 100px.
Using this keypoint together with the middle_kp to create a parallel line to the x axis</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>top_kp</code></strong> :&ensp;<code>Keypoint</code></dt>
<dd>Some keypoint from head region</dd>
<dt><strong><code>middle_kp</code></strong> :&ensp;<code>Keypoint</code></dt>
<dd>Some keypoint from upper body region</dd>
<dt><strong><code>bottom_kp</code></strong> :&ensp;<code>Keypoint</code></dt>
<dd>Some keypoint from lower body region</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Keypoint</code></dt>
<dd>returns an reference Keypoint.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_horizantal_b_reference(top_kp: Keypoint, middle_kp: Keypoint, bottom_kp: Keypoint) -&gt; Keypoint:
    &#34;&#34;&#34;Returns an reference Keypoint by adding or substracting 100px from middle_kp x-coordinate.
    If the smaller angle between the three keypoints is on the left side we substract 100px else we add 100px.
    Using this keypoint together with the middle_kp to create a parallel line to the x axis

    Args:
        top_kp (Keypoint): Some keypoint from head region
        middle_kp (Keypoint): Some keypoint from upper body region
        bottom_kp (Keypoint): Some keypoint from lower body region

    Returns:
        Keypoint: returns an reference Keypoint.
    &#34;&#34;&#34;
    vector_a = keypoint_to_vector(top_kp, middle_kp)
    vector_c = keypoint_to_vector(bottom_kp, middle_kp)
    # NOTE: checking angle_left_opening has the same effect as to check if biscetion point is positioned to the left or right of the neck point
    angle_left_opening = np.cross(vector_a, vector_c) &lt; 0
    return Keypoint(middle_kp.x - 100, middle_kp.y) if angle_left_opening else Keypoint(middle_kp.x + 100, middle_kp.y)</code></pre>
</details>
</dd>
<dt id="compoelem.generate.bisection.keypoint_to_np"><code class="name flex">
<span>def <span class="ident">keypoint_to_np</span></span>(<span>keypoint: <a title="compoelem.types.Keypoint" href="../types.html#compoelem.types.Keypoint">Keypoint</a>) ‑> numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def keypoint_to_np(keypoint: Keypoint) -&gt; np.ndarray:
    return np.array([keypoint.x, keypoint.y])</code></pre>
</details>
</dd>
<dt id="compoelem.generate.bisection.keypoint_to_point"><code class="name flex">
<span>def <span class="ident">keypoint_to_point</span></span>(<span>k: <a title="compoelem.types.Keypoint" href="../types.html#compoelem.types.Keypoint">Keypoint</a>) ‑> shapely.geometry.point.Point</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def keypoint_to_point(k: Keypoint) -&gt; Point:
    return Point(k.x, k.y)</code></pre>
</details>
</dd>
<dt id="compoelem.generate.bisection.keypoint_to_vector"><code class="name flex">
<span>def <span class="ident">keypoint_to_vector</span></span>(<span>a: <a title="compoelem.types.Keypoint" href="../types.html#compoelem.types.Keypoint">Keypoint</a>, b: <a title="compoelem.types.Keypoint" href="../types.html#compoelem.types.Keypoint">Keypoint</a>) ‑> numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def keypoint_to_vector(a: Keypoint, b: Keypoint) -&gt; np.ndarray:
    return keypoint_to_np(a) - keypoint_to_np(b)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="compoelem.generate" href="index.html">compoelem.generate</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="compoelem.generate.bisection.get_angle" href="#compoelem.generate.bisection.get_angle">get_angle</a></code></li>
<li><code><a title="compoelem.generate.bisection.get_angle_in_respect_to_x" href="#compoelem.generate.bisection.get_angle_in_respect_to_x">get_angle_in_respect_to_x</a></code></li>
<li><code><a title="compoelem.generate.bisection.get_bisection_cone" href="#compoelem.generate.bisection.get_bisection_cone">get_bisection_cone</a></code></li>
<li><code><a title="compoelem.generate.bisection.get_bisection_point" href="#compoelem.generate.bisection.get_bisection_point">get_bisection_point</a></code></li>
<li><code><a title="compoelem.generate.bisection.get_bisection_point_from_angle" href="#compoelem.generate.bisection.get_bisection_point_from_angle">get_bisection_point_from_angle</a></code></li>
<li><code><a title="compoelem.generate.bisection.get_centroids_for_bisection" href="#compoelem.generate.bisection.get_centroids_for_bisection">get_centroids_for_bisection</a></code></li>
<li><code><a title="compoelem.generate.bisection.get_horizantal_b_reference" href="#compoelem.generate.bisection.get_horizantal_b_reference">get_horizantal_b_reference</a></code></li>
<li><code><a title="compoelem.generate.bisection.keypoint_to_np" href="#compoelem.generate.bisection.keypoint_to_np">keypoint_to_np</a></code></li>
<li><code><a title="compoelem.generate.bisection.keypoint_to_point" href="#compoelem.generate.bisection.keypoint_to_point">keypoint_to_point</a></code></li>
<li><code><a title="compoelem.generate.bisection.keypoint_to_vector" href="#compoelem.generate.bisection.keypoint_to_vector">keypoint_to_vector</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>